{"/en/blog/buildingablog/":{"data":{"conclusion#Conclusion":"As you can see, there is still some work to be done (which I plan to address someday, hopefully), but for now the blog meets my needs.\nRegarding the technologies, I really enjoyed working with them. It was a great experience developing this app using the GOTTH stack, as all the tools have supportive communities and excellent documentation.\nI liked it so much that I’m planning to build a simple web app for organizing personal finances (e.g., tracking monthly expenses), since I haven’t found a good free app available. Perhaps someday I’ll write a post about that as well.\nUntil then, thanks for taking the time to read this.\nCheck out my Portfólio too. There’s a post coming about it soon too.","database#Database":"Since this is a relatively simple app, I chose not to use an ORM and instead went with SQLC—a tool that compiles SQL queries into Go code, ensuring type safety.\nFor database migrations, I’m using golang-migrate.","how-it-started#How it Started":"In this post, I’m going to talk in more depth about why and how I built this blog.\nHow it StartedMany months ago, I started watching a YouTuber named ThePrimeAgen. Every now and then, he talks about Golang and expresses his enthusiasm for the language. Intrigued by his insights, I decided to give Golang a try to see what it was all about.\nI began experimenting with Golang about six months ago, solving some BeeCrowd problems just to get the hang of it. Soon after, I built a few simple REST API servers, as Golang is very well-suited for this kind of software.\nBut why create a blog?\nI’m a big fan of tech blogs, and since most of my knowledge has come from reading them, I thought it would be cool to have my own. As I mentioned in my previous post , I also wanted to test my skills, deploy an application beyond localhost, and improve my writing.","how-it-works#How it works":"","htmx-and-alpinejs#HTMX and AlpineJS":"I used a small amount of HTMX primarily for making HTTP requests—such as deleting a post, handling login, and enabling live reload in the editor.\nAlpineJS is employed mainly to toggle the visibility of the table of contents (TOC) and to switch the color scheme.","posthandler#PostHandler":"The server consists of a PostHandler and an AuthHandler. The authentication part is straightforward, so I’ll focus on the PostHandler, which comprises seven functions to manage posts:\nGetPosts: Renders a list of post cards as HTML using a Templ template. ViewPost: Renders the full post. DeletePost: Deletes the specified post. Editor: Renders a simple editor where I can input the post title, slug, description, and Markdown content (it’s pretty basic at the moment, so no images). Edit: Edits an existing post. CreatePost: Generates the table of contents, converts the Markdown content into HTML, and saves the post. ParseMarkdown: Similar to CreatePost but returns the HTML content instead—this is used for live reloading in the editor.","technologies#Technologies":"For building this blog, I decided to use only technologies I had never used before, so I chose the GOTTH stack:\nGolang: to serve the web app Templ: for HTML templating TailwindCSS: for styling and beautiful design HTMX: for better interactivity and navigation AlpineJS: for interactive animations I also used PostgreSQL as the database, though I plan to switch to SQLite in the future.","the-backend#The Backend":"I developed the backend as a package so that it could be reused by anyone who wants a simple blog without much hassle. Currently, the only customization options available are for the blog title, page title, and admin user.\nI plan to add more customization options — such as color schemes and layout adjustments — in the future once I address other priorities.\nThe package is named Blogo (a blend of “Blog” and “Go”) and requires the following configuration:\ntype BlogoConfig struct { BlogName string Title string Port string DB *sql.DB AuthConfig *auth.AuthConfig Logger *log.Logger Location *time.Location Queries *repository.Queries } You can run the server with:\nblog.Start() A more detailed example is available in my repo , where you can see my personal blog configuration.","the-frontend#The Frontend":"As mentioned earlier, the frontend is essentially pure HTML with a small amount of JavaScript provided by HTMX and AlpineJS, and styled with TailwindCSS.","why-templ#Why Templ?":"Templ allows for creating reusable HTML components that integrate seamlessly with Golang code. For example, consider the MainPage component that lists the post cards:\ntempl MainPage(blogname string, posts []repository.Post, authenticated bool) { if authenticated { @components.Header(blogname, []string{\"New Post\", \"Logout\"}, []string{\"/editor\", \"/logout\"}) } else { @components.Header(blogname, []string{\"Login\"}, []string{\"/login\"}) } \u003cul id=\"posts-list\" class=\"min-h-screen flex flex-col items-center\"\u003e for _, post := range posts { @components.PostCard(post, authenticated) } \u003c/ul\u003e } Note: The Header and PostCard components are defined in the components package.\nThe Golang code for rendering the page is straightforward:\nmainPage := pages.MainPage(h.blogName, h.pagetitle, posts, authenticated) mainPage.Render(ctx, w) // w is the http.ResponseWriter"},"title":"Building my Blog"},"/en/blog/kvstore/":{"data":{"a-kv-store-with-paxos#A KV-Store with Paxos":"Right, but how do we combine the two things?\nAs mentioned earlier, in a real system using Paxos, we would have a continuous flow of agreed commands applied to a distributed state. Thus, we can understand the KV-store state as the result of applying in order all commands decided by Paxos rounds.\nFor this project, we defined the following commands:\nSET key value DELETE key Example:\nIf we have the following 2 decided commands:\nSET key1 value1 SET key2 value2 The state would be: { key1: value1, key2: value2 }\nIf we did DELETE key1, we would have: { key2: value2 }","client#Client":"To be able to use the KV-Store without having direct access to the nodes and a way to execute these functions through them, all nodes also implement the following gRPC definition:\nservice KVStore{ rpc Get(GetRequest) returns (GetResponse); rpc Set(SetRequest) returns (SetResponse); rpc Delete(DeleteRequest) returns (DeleteResponse); rpc List(ListRequest) returns (ListResponse); rpc ListLog(ListRequest) returns (ListLogResponse); rpc TryElectSelf(TryElectRequest) returns (TryElectResponse); } message GetRequest { string key = 1; } message GetResponse { string value = 1; bool found = 2; string error_message = 3; } message SetRequest { string key = 1; string value = 2; } message SetResponse { bool success = 1; string error_message = 2; } message DeleteRequest { string key = 1; } message DeleteResponse { bool success = 1; string error_message = 2; } message ListRequest{} message ListResponse { repeated KeyValuePair pairs = 1; string error_message = 3; // Error message, if any } message KeyValuePair { string key = 1; string value = 2; } message ListLogResponse { repeated LogEntry entries = 1; string errorMessage = 2; } message LogEntry { int64 slot_id = 1; Command command = 2; // Command associated with the log } message Command{ paxos.CommandType type = 1; // command type string key = 2; // key of the value to be manipulated string value = 3; // value to be manipulated, if applicable int64 proposal_id = 4; // proposal number associated with the command } message TryElectRequest { } message TryElectResponse { bool success = 1; // Indicates if election was successful string error_message = 2; // Error message, if any } Thus, it’s possible to use a gRPC client that makes these calls to a specific node.\nFor better user interaction, an HTTP server (also in Golang) was also developed, which acts as a gRPC client for the KVStore service. Thus, accompanied by the frontend developed in React, we can visualize and send commands to each system node.","conclusion#Conclusion":"The implementation of this project was challenging and brought a lot of learning about concurrency problems and distributed systems, in addition to enabling greater practice with Golang, which is a very interesting language for concurrent systems and the gRPC communication protocol.\nThe code for the project can be found in our GitHub Repository along with instructions on how to run all the services involved.","grpc-and-protobuf#gRPC and protobuf":"gRPC communication requires a protobuf definition of the functions, parameters, and responses implemented by the nodes.\nEvery node in our system implements the following functions:\nservice Paxos{ rpc Prepare(PrepareRequest) returns (PrepareResponse); rpc Accept(AcceptRequest) returns (AcceptResponse); rpc ProposeLeader(ProposeLeaderRequest) returns (ProposeLeaderResponse); } message PrepareRequest { int64 proposal_id = 1; // proposal number int64 slot_id = 2; // proposal slot number } enum CommandType{ UNKNOWN = 0; // unknown command SET = 1; // command to set a value DELETE = 2; // command to delete a value } message Command{ CommandType type = 1; // command type string key = 2; // key of the value to be manipulated bytes value = 3; // value to be manipulated, if applicable int64 proposal_id = 4; // proposal number associated with the command } message PrepareResponse { bool success = 1; string error_message = 2; // error message, if any int64 accepted_proposal_id = 3; // accepted proposal number Command accepted_command = 4; // accepted command, if any int64 current_proposal_id = 5; // current proposal number } message AcceptRequest { int64 proposal_id = 1; // proposal number int64 slot_id = 2; // proposal slot number Command command = 3; // command to be accepted } message AcceptResponse { bool success = 1; // indicates if acceptance was successful int64 current_proposal_id = 2; // accepted proposal number string error_message = 3; // error message, if any } In this case, the Prepare function corresponds to PHASE 1 and the Accept function corresponds to PHASE 2, with PrepareRequest being 1a and PrepareResponse being 1b, and likewise for accept.","implementation#Implementation":"For the implementation of this project, we used Golang as the main language, since it has very good support for concurrency and distributed communication, facilitating the development of necessary functionalities. For communication between nodes, we used gRPC.","leader-election#Leader Election":"To elect the leader of a Paxos system, we can use Paxos itself, but it’s a bit more complex due to some peculiarities.\nHow does a node decide if it should try to elect itself as leader?\nThe simplest way we could think of is through heartbeats, where the current leader periodically sends a heartbeat message to all network nodes. If a node goes more than a certain time without receiving a heartbeat from the leader, it assumes the leader is offline and after a certain random delay (to avoid multiple nodes initiating election at the same time) it tries to propose itself as leader.\nFor this part, we used the following RPC functions:\nservice Paxos{ rpc ProposeLeader(ProposeLeaderRequest) returns (ProposeLeaderResponse); rpc SendHeartbeat(LeaderHeartbeat) returns (LeaderHeartbeatResponse); } message ProposeLeaderRequest{ int64 proposal_id = 1; // Proposal number for leader election string candidate_address = 2; // Leader candidate address } message ProposeLeaderResponse{ bool success = 1; string error_message = 2; // Error message, if any int64 current_highest_leader_proposal_id = 3; // Current leader's proposal number string current_leader_address = 4; // Current leader's address int64 highest_decided_slot_id = 5; // Highest slot decided so far } message LeaderHeartbeat{ string leader_address = 1; // Leader address int64 current_proposal_id = 2; // Leader's current proposal number int64 highest_decided_slot_id = 3; // Highest slot decided so far } message LeaderHeartbeatResponse{ bool success = 1; // Indicates if heartbeat was successful string error_message = 2; // Error message, if any int64 known_highest_slot_id = 3; // Highest slot the Acceptor/Learner knows } Additionally, to avoid problems we encountered during testing, if more than one node perceives the lack of a leader and they start an election, if the node receives any indication that an election is already happening with an ID greater than its own election, whether by receiving the proposal directly or by receiving a denial from another node containing this higher ID, it aborts its own election.","paxos-algorithm#Paxos Algorithm":"The Paxos algorithm, proposed by Leslie Lamport, is a robust solution to the consensus problem in asynchronous distributed systems with failures. It solves the consensus problem by ensuring that a set of nodes reaches agreement on a single value, even if up to half of the network nodes fail. To achieve this, Paxos operates in three main roles: Proposer (proposes values), Acceptor (accepts or rejects proposals), and Learner (learns the agreed value). It’s a complex algorithm, but its reliability makes it ideal for systems that require greater consistency.\nTo understand how Paxos guarantees this consensus, let’s detail its two main phases of operation:\nPhase 1, preparation:\n1a. Prepare: A Proposer creates a message called “Prepare”. This message is identified by a unique number N, which must be greater than any number previously used in a message. This message is sent to a Quorum of Acceptors. 1b. Promise: Upon receiving a message, an Acceptor checks if N is greater than any proposal number it has already promised to accept. If so, it responds with a Promise, committing not to accept proposals with a number lower than N and informing the highest-numbered proposal, N’, that it has already accepted, along with its value, V’. If N is not greater, it simply ignores or responds with denial. Phase 2, acceptance:\n2a. Accept: If the Proposer receives Promises from a Quorum of Acceptors, it chooses a value V for its proposal. If any Acceptor informed having accepted a previous proposal, the Proposer must choose the value V’ from the proposal with the highest number N’. Otherwise, it can choose a new value. Then, the Proposer sends an Accept(N, V) message to the Quorum of Acceptors. 2b. Accepted: Upon receiving an Accept(N, V) message, an Acceptor checks if it has already promised not to accept proposals with a number lower than N. If there is no such promise, it accepts the proposal, records the value V as accepted, and sends an Accepted(N, V) message to the Learners. If there’s already a promise for a higher N, it simply ignores. In Paxos, consensus is reached when the majority of Acceptors agree on the same proposal identifier number. Since each identifier is unique to a Proposer and a single value is associated with that identifier, ensuring that the majority accepts the same proposal ID implies they will agree on the same value.\nHowever, this entire process is used to choose only one value. In a real scenario, we would have a continuous flow of agreed values acting as commands for a distributed state machine. However, if each command were the result of a Paxos instance, there would be significant network overhead, since for each command 2 messages would be sent to all network nodes (1a and 2a) and one node would have to receive 2 messages from each network node (1b and 2b).\nTo mitigate this, a crucial optimization is the election of a Leader, which simplifies Phase 1 for subsequent decisions, reducing network traffic.","registry#Registry":"Right, but how do the nodes and HTTP server know the node addresses to be able to make gRPC requests?\nWe also developed a simple registry service, also through gRPC, in which each node registers upon startup and allows the addresses of all system nodes to be queried. In addition to using heartbeats for knowledge of which node is active or not.\nThe registry is defined by the following protobuf:\nservice Registry { rpc Register(RegisterRequest) returns (RegisterResponse); rpc ListAll(google.protobuf.Empty) returns (ListResponse); rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse); }","synchronization#Synchronization":"The synchronization part concerns the synchronization of the decided commands state between all nodes.\nIf we have a system with 50 nodes running, we insert some values, and then 10 new nodes are connected, they need to know the history of values decided by the other 50. For this, we also have the following function:\nservice Paxos{ rpc Learn(LearnRequest) returns (LearnResponse); } message LearnRequest{ int64 slot_id = 1; // Slot number being learned } message LearnResponse{ bool decided = 1; // Indicates if the slot was decided Command command = 2; // Command associated with the slot, if decided } When a node receives a HeartBeat, the number of the last slot decided by the system is sent along, and if it’s greater than what the node has in its internal state, it executes Learn until it synchronizes its entire state.\nThis synchronization is also done during the election of a new leader if necessary.","the-proposal#The Proposal":"Unveiling Paxos in Practice: How We Built a Distributed KV-Store\nThe ProposalDistributed systems are the backbone of many modern applications, but managing consistency and fault tolerance in them is a challenge. In this post, I’ll share our journey in developing a distributed Key-Value Store for a college course, using the complex but robust Paxos consensus algorithm and the Go language.","what-is-a-distributed-consensus-algorithm#What is a Distributed Consensus Algorithm?":"To provide some context, let’s first define a Distributed System.\nDistributed systems are characterized by a set of independent computers that present themselves to the user as a single, coherent system. These systems are designed to achieve scalability, availability, and fault tolerance—essential characteristics in modern applications such as distributed databases, file systems, and cloud computing platforms.\nWith this in mind, one of the greatest difficulties in these distributed environments is coordination between the participating nodes of the application, especially when it’s necessary to guarantee consistency between replicated states in scenarios where failures (unavailable nodes, network problems) can occur.\nFaced with this problem, distributed consensus algorithms were developed, such as Paxos or Raft, which serve to coordinate nodes and ensure agreement on values or operations, even under adverse conditions.","what-is-a-kv-store#What is a KV-Store?":"In summary, a Key-Value store is a simpler and more efficient type of database that stores data as key-value pairs. It has better read and write performance since it doesn’t have a rigid schema or relationships between stored values. It’s widely used in distributed systems and for caching."},"title":"KVStore"},"/en/blog/windowsvm/":{"data":{"":"In this post, I’ll share and document for my future use the process of creating a Windows 11 virtual machine on Linux using QEMU/KVM.","additional-configurations#Additional Configurations":"In the Overview menu, change the firmware to UEFI x86_64: /usr/share/edk2/x64/OVMF_CODE.secboot.4m.fd\nIf you don’t have OVMF installed, you can install it with the following command:\nsudo pacman -S edk2-ovmf Click “Apply”.\nNow let’s add the VirtIO drivers you downloaded earlier.\nGo to Add Hardware \u003e Storage \u003e Select or create custom storage \u003e Browse Local and select the VirtIO drivers ISO file. Then change the device type to CDROM device and click Finish.\nIt’s also interesting to change the hard drive’s bus type to VirtIO to improve performance. Go to SATA Disk 1 and change the bus type to VirtIO. Click Apply.\nFinally, let’s emulate the TPM chip, which is required for Windows 11.\nThere should be a menu by default that says TPM vNone. Go to it, open the advanced options menu and select 2.0 in the version dropdown. Then click Apply.\nNow you can start the installation by clicking Begin Installation.","configure-hard-drive#Configure Hard Drive":"Here you can choose the size of the virtual hard drive. I recommend at least 64GB for Windows 11, but if you plan to install many programs, consider increasing this value, especially if you’re going to use it for gaming.\nThere’s also the possibility of using an entire existing disk with direct access, via Passthrough, but that’s a subject for another post and is more advanced.","configure-memory-and-cpu#Configure Memory and CPU":"Here choose the amount of RAM and CPU you want to allocate to the virtual machine.\nI recommend at least 8GB of RAM and 4 CPU cores for good performance.\nAfter configuring, click “Forward”.","create-virtual-machine#Create Virtual Machine":"Here, keep the default options and click “Forward”.","final-considerations#Final Considerations":"Well, the idea of this post was to document the process I followed to install Windows 11 on Linux using QEMU/KVM, so I can refer to it in the future if I need to do it again and to make it available to anyone else who might need it, since I myself had difficulties finding a complete and up-to-date guide on the subject.\nIn the future I intend to make more posts about advanced configurations, such as GPU passthrough, USB, CPU pinning, etc.\nAdditionally, I want to make it clear that this process may vary depending on the hardware and Linux distribution you’re using, so it’s always good to consult the official QEMU/KVM and VirtIO documentation for more details.\nAlso, obviously, as it’s a virtual machine, don’t expect performance equal to that of a native system, but with the right configurations, the performance can be very good and sufficient for most tasks.\nIn my case, I have a relatively powerful machine, with the following configuration:\nSo I can allocate 16GB of RAM and 8 CPU cores to the virtual machine, which is more than enough for my use, while I can still use Linux normally.\nThis text was translated by AI.","finish-configuration#Finish Configuration":"Now give the virtual machine a name and check the option “Customize configuration before install” to make some additional configurations.","host-configuration#Host Configuration":"Before starting to configure the virtual machine, let’s first configure libvirt to allow the current user to manage virtual machines without needing superuser privileges.\nsudo usermod -aG libvirt $(whoami) newgrp libvirt Now, let’s start the libvirt service and enable it to start automatically on system boot:\nsudo systemctl enable --now libvirtd","host-configurations#Host Configurations":"Now that we have Windows installed, let’s make some additional configurations on the host to improve performance.\nFirst, we can remove the CD-ROM with the VirtIO drivers, since we don’t need them anymore. To do this, select the CD-ROM from the hardware list and click Remove. It’s probably SATA CDROM 2.\nIf you want to use a camera, as in my case, I’m doing the installation on a laptop, to add the camera to the VM, just go to Add Hardware \u003e USB Host Device and find your device and add it.\nAdditionally, at least on my laptop, I had problems with audio input, so I had to make the following configuration in the Overview tab by manually editing the configuration XML, replacing the audio part with this configuration:","libvirt-configuration#Libvirt Configuration":"During the VM installation on my machine, I had some issues with network access and also user permissions, so I had to make the following changes:\nIn /etc/libvirt/qemu.conf, uncomment the user line and change the value to your user\n... # The user for QEMU processes run by the system instance. It can be # specified as a user name or as a user id. The qemu driver will try to # parse this value first as a name and then, if the name doesn't exist, # as a user id. # # Since a sequence of digits is a valid user name, a leading plus sign # can be used to ensure that a user id will not be interpreted as a user # name. # # Some examples of valid values are: # # user = \"qemu\" # A user named \"qemu\" # user = \"+0\" # Super user (uid=0) # user = \"100\" # A user named \"100\" or a user with uid=100 # user = \"your_username\" ... Additionally, I had to change the firewall backend to use iptables, in /etc/libvirt/network.conf\n... # Master configuration file for the network driver. # All settings described here are optional - if omitted, sensible # defaults are used. # firewall_backend: # # determines which subsystem to use to setup firewall packet # filtering rules for virtual networks. # # Supported settings: # # iptables - use iptables commands to construct the firewall # nftables - use nft commands to construct the firewall # # If firewall_backend isn't configured, libvirt will choose the # first available backend from the following list: # # [nftables, iptables] # # If no backend is available on the host, then the network driver # will fail to start, and an error will be logged. # # (NB: switching from one backend to another while there are active # virtual networks *is* supported. The change will take place the # next time that libvirtd/virtnetworkd is restarted - all existing # virtual networks will have their old firewalls removed, and then # reloaded using the new backend.) # firewall_backend = \"iptables\" ... If you don’t have iptables installed, you can install it with the following command:\nsudo pacman -S iptables","post-installation-configuration#Post-Installation Configuration":"Once Windows is finally installed, let’s make some additional configurations to improve performance and integration with Linux.\nOpen file explorer and go to the CD-ROM drive where the VirtIO drivers are.\nRun the virtio-win-gt-x64.msi installer and follow the steps to install all drivers.\nThen install the virtio-win-guest-tools which will install the QEMU Guest Agent, which is a service that allows communication between the host and the virtual machine, enabling features such as safe shutdown, time synchronization, etc.\nOnce installed, you can go to the virt-manager menu View -\u003e Scale to Display and enable Auto resize VM with window so that the virtual machine resolution automatically adjusts to the window size.\nNow you can shut down the machine so we can make a few more configurations.","qemukvm#QEMU/KVM":"As I’m an Arch Linux user, I’ll use the pacman package manager to install the necessary packages. If you’re using another distro, adapt the commands as needed.\nsudo pacman -S qemu-full libvirt virt-manager virt-viewer dnsmasq qemu-full: The hardware emulator and hypervisor. libvirt: Library for managing virtual machines. virt-manager: Graphical interface for managing virtual machines. virt-viewer: Tool for viewing virtual machines. dnsmasq: Lightweight DHCP and DNS server.","requirements#Requirements":"A computer with Linux installed (preferably a distro that supports KVM, such as Ubuntu, Fedora, Arch, etc).","select-iso#Select ISO":"On this second screen, find the Windows 11 ISO you downloaded earlier by clicking “Browse” and then “Browse Local”.\nAfter selecting the ISO, click “Forward”.","virtio-drivers#VirtIO Drivers":"For the integration between Windows and QEMU/KVM to work properly, you’ll need the VirtIO drivers.\nThis is because Windows 11 doesn’t natively recognize the virtual devices created by QEMU/KVM, such as the disk and network card.\nAdditionally, through these drivers, you’ll have better performance with almost native performance, since Windows will know it’s running on a virtual machine and will optimize resource usage.\nTo install on Arch Linux, you can use the following command:\nsudo pacman -s virtio-win Or you can download directly from the official website: VirtIO Drivers","virtio-drivers-installation#VirtIO Drivers Installation":"On the disk selection screen, since we chose to use the virtio bus type, Windows doesn’t recognize the hard drive, so we need to load the VirtIO drivers.\nIf the disk appears (in case you kept SATA) the disk will appear, but still install the drivers as they are used for other devices as well.\nTo do this, go to Load Driver.\nOpen the CD-ROM drive and select the folder viostor\\w11\\amd64 and click OK.\nDisable the option to show only compatible drivers and click install.\nThen go again to Load Driver \u003e Browse and select the folder NetKVM\\w11\\amd64 and click OK and install.\nNow you can click Next and continue the installation normally.\nThe process may take a while, so be patient. On my machine it took about 15 minutes to complete and go to the initial Windows configuration part.\nIn this part, follow the steps to configure Windows as you prefer.\nIf an error screen appears saying it’s not possible to connect to the internet, probably the driver missed some network-related configuration mentioned earlier, so go back and check if everything is correct.\nIf you went to an update verification screen, most likely everything went well, and you just need to wait a bit longer.\nSince Microsoft is annoying, it will ask you to log into a Microsoft account or create one, and so far I haven’t found out if it’s possible to skip this step, so create a Microsoft account or use one you already have.","virtual-machine-configuration#Virtual Machine Configuration":"Now let’s get to the interesting part, which is configuring and installing the virtual machine.\nOnce you have everything installed and configured, you can start virt-manager (Virtual Machine Manager) from your system menu or by typing virt-manager in the terminal or searching in your favorite launcher.\nIf everything worked, you’ll see an interface like this:\nNow, click on the icon to create a new virtual machine and follow these steps:","why#Why?":"Well, if you, like me, prefer to use some Linux distro as your main system or, like me, don’t like Windows, but need to use Windows for some specific tasks, such as work, or some software that only runs on Windows, or games that only run on Windows (although this is no longer quite as true), or even for software development that needs to be tested on Windows, a virtual machine is a great solution.","windows-11-installation#Windows 11 Installation":"When starting the installation, you’ll see on the screen to press any key to boot from CD/DVD. Press any key and you’ll be redirected to the Windows installation screen.\nDo the initial language and keyboard configuration and click Next.\nIn the Product Key tab, if you have a key, enter it here. Otherwise, click I don't have a product key to continue the installation without the key.\nIn the image selection, select Windows 11 Home.","windows-11-iso#Windows 11 ISO":"You can download the Windows 11 ISO directly from Microsoft’s website: Download Windows 11"},"title":"Windows VM on Linux"}}