{"/blog/":{"data":{"":"Bem-vindo à página de lista do blog!"},"title":"Blog Posts"},"/blog/buildingablog/":{"data":{"banco-de-dados#Banco de Dados":"Como esta é uma aplicação relativamente simples, escolhi não usar um ORM e, em vez disso, optei pelo SQLC — uma ferramenta que compila consultas SQL em código Go, garantindo segurança de tipos.\nPara migrações de banco de dados, estou usando golang-migrate.","como-começou#Como Começou":"Neste post, vou falar mais profundamente sobre por que e como construí este blog.\nComo ComeçouHá muitos meses, comecei a assistir um YouTuber chamado ThePrimeAgen. De vez em quando, ele fala sobre Golang e expressa seu entusiasmo pela linguagem. Intrigado por suas percepções, decidi dar uma chance ao Golang para ver do que se tratava.\nComecei a experimentar com Golang há cerca de seis meses, resolvendo alguns problemas do BeeCrowd apenas para pegar o jeito. Logo depois, construí alguns servidores REST API simples, já que Golang é muito adequado para esse tipo de software.\nMas por que criar um blog?\nSou um grande fã de blogs de tecnologia e, como a maior parte do meu conhecimento veio da leitura deles, achei que seria legal ter o meu próprio. Como mencionei em meu post anterior , também queria testar minhas habilidades, implantar uma aplicação além do localhost e melhorar minha escrita.","como-funciona#Como Funciona":"","conclusão#Conclusão":"Como você pode ver, ainda há algum trabalho a ser feito (que planejo abordar algum dia, espero), mas por enquanto o blog atende minhas necessidades.\nEm relação às tecnologias, realmente gostei de trabalhar com elas. Foi uma ótima experiência desenvolver esta aplicação usando a stack GOTTH, já que todas as ferramentas têm comunidades solidárias e excelente documentação.\nGostei tanto que estou planejando construir uma aplicação web simples para organizar finanças pessoais (por exemplo, rastrear despesas mensais), já que não encontrei um bom aplicativo gratuito disponível. Talvez algum dia eu escreva um post sobre isso também.\nAté lá, obrigado por dedicar seu tempo para ler isto.\nConfira meu Portfólio também. Em breve haverá um post sobre ele também.","htmx-e-alpinejs#HTMX e AlpineJS":"Usei uma pequena quantidade de HTMX principalmente para fazer requisições HTTP — como deletar um post, lidar com login e habilitar recarregamento ao vivo no editor.\nAlpineJS é empregado principalmente para alternar a visibilidade do índice (TOC) e para mudar o esquema de cores.","o-backend#O Backend":"Desenvolvi o backend como um pacote para que pudesse ser reutilizado por qualquer pessoa que queira um blog simples sem muito trabalho. Atualmente, as únicas opções de customização disponíveis são para o título do blog, título da página e usuário administrador.\nPlanejo adicionar mais opções de customização — como esquemas de cores e ajustes de layout — no futuro, uma vez que eu atenda outras prioridades.\nO pacote se chama Blogo (uma mistura de “Blog” e “Go”) e requer a seguinte configuração:\ntype BlogoConfig struct { BlogName string Title string Port string DB *sql.DB AuthConfig *auth.AuthConfig Logger *log.Logger Location *time.Location Queries *repository.Queries } Você pode executar o servidor com:\nblog.Start() Um exemplo mais detalhado está disponível no meu repositório , onde você pode ver a configuração do meu blog pessoal.","o-frontend#O Frontend":"Como mencionado anteriormente, o frontend é essencialmente HTML puro com uma pequena quantidade de JavaScript fornecida por HTMX e AlpineJS, e estilizado com TailwindCSS.","por-que-templ#Por que Templ?":"Templ permite criar componentes HTML reutilizáveis que se integram perfeitamente com código Golang. Por exemplo, considere o componente MainPage que lista os cards de posts:\ntempl MainPage(blogname string, posts []repository.Post, authenticated bool) { if authenticated { @components.Header(blogname, []string{\"New Post\", \"Logout\"}, []string{\"/editor\", \"/logout\"}) } else { @components.Header(blogname, []string{\"Login\"}, []string{\"/login\"}) } \u003cul id=\"posts-list\" class=\"min-h-screen flex flex-col items-center\"\u003e for _, post := range posts { @components.PostCard(post, authenticated) } \u003c/ul\u003e } Nota: Os componentes Header e PostCard são definidos no pacote components.\nO código Golang para renderizar a página é direto:\nmainPage := pages.MainPage(h.blogName, h.pagetitle, posts, authenticated) mainPage.Render(ctx, w) // w é o http.ResponseWriter","posthandler#PostHandler":"O servidor consiste em um PostHandler e um AuthHandler. A parte de autenticação é direta, então vou focar no PostHandler, que compreende sete funções para gerenciar posts:\nGetPosts: Renderiza uma lista de cards de posts como HTML usando um template Templ. ViewPost: Renderiza o post completo. DeletePost: Deleta o post especificado. Editor: Renderiza um editor simples onde posso inserir o título do post, slug, descrição e conteúdo em Markdown (é bem básico no momento, então sem imagens). Edit: Edita um post existente. CreatePost: Gera o índice, converte o conteúdo Markdown em HTML e salva o post. ParseMarkdown: Similar ao CreatePost mas retorna o conteúdo HTML — isso é usado para recarregamento ao vivo no editor.","tecnologias#Tecnologias":"Para construir este blog, decidi usar apenas tecnologias que nunca havia usado antes, então escolhi a stack GOTTH:\nGolang: para servir a aplicação web Templ: para templates HTML TailwindCSS: para estilização e design bonito HTMX: para melhor interatividade e navegação AlpineJS: para animações interativas Também usei PostgreSQL como banco de dados, embora planeje mudar para SQLite no futuro."},"title":"Construindo meu Blog"},"/blog/kvstore/":{"data":{"a-proposta#A Proposta":"Desvendando Paxos na Prática: Como Construímos um KV-Store Distribuído\nA PropostaSistemas distribuídos são a espinha dorsal de muitas aplicações modernas, mas gerenciar a consistência e a tolerância a falhas neles é um desafio. Neste post, vou compartilhar nossa jornada no desenvolvimento de um Key-Value Store distribuído para uma disciplina de faculdade, utilizando o complexo, mas robusto, algoritmo de consenso Paxos e a linguagem Go.","algoritmo-paxos#Algoritmo Paxos":"O algoritmo Paxos, proposto por Leslie Lamport, é uma solução robusta para o problema do consenso em sistemas distribuídos assíncronos com falhas. Ele resolve o problema do consenso garantindo que um conjunto de nós chegue a um acordo sobre um único valor, mesmo que até metade dos nós da rede falhem. Para isso, o Paxos opera em três papéis principais: Proposer (propõe valores), Acceptor (aceita ou rejeita propostas) e Learner (aprende o valor acordado). É um algoritmo complexo, mas sua confiabilidade o torna ideal para sistemas que exigem maior consistência.\nPara entender como o Paxos garante esse consenso, vamos detalhar suas duas fases principais de operação:\nFase 1, de preparação:\n1a. Preparar: Um Proponente (Proposer) cria uma mensagem, chamada de “Prepare”. Essa mensagem é identificada por um número único N, que deve ser maior que qualquer número usado anteriormente em uma mensagem. Essa mensagem é enviada para um Quórum de Aceitadores (Acceptors). 1b. Promessa: Ao receber uma mensagem, um Aceitador verifica se N é maior do que qualquer número de proposta que ele já tenha prometido aceitar. Caso seja, ele responde com uma Promise, comprometendo-se a não aceitar propostas com número menor que N e informando a proposta de maior número, N’ que ele já aceitou, juntamente com seu valor, V’. Se N não for maior, apenas ignora ou responde com negação. Fase 2, de aceitação:\n2a. Aceitar: Se o Proponente receber Promises de um Quórum de Aceitadores, ele escolhe um valor V para sua proposta. Se algum Aceitador informou ter aceitado uma proposta anterior, o Proponente deve escolher o valor V’ da proposta com o maior número N’. Caso contrário, pode escolher um valor novo. Então, o Proponente envia uma mensagem de Accept(N, V) para o Quórum de Aceitadores. 2b. Aceito: Ao receber uma mensagem Accept(N, V), um Aceitador verifica se já prometeu não aceitar propostas com um número menor que N. Se não houver tal promessa, ele aceita a proposta, registra o valor V como aceito e envia uma mensagem Accepted(N, V) para os Aprendizes (Learners). Se já houver uma promessa para um N maior, apenas ignora. Em Paxos, o consenso é alcançado quando a maioria dos Aceitadores concorda com um mesmo número de identificador de proposta. Como cada identificador é único para um Proponente e um único valor é associado a esse identificador, garantir que a maioria aceite o mesmo ID de proposta implica que eles concordarão sobre o mesmo valor.\nNo entanto, todo esse processo é utilizado para escolher apenas um valor, em um cenário real, teríamos um fluxo contínuo de valores acordados atuando como comandos para uma máquina de estados distribuídos. No entando, se cada comando for resultado de uma instância de Paxos, haveria uma sobrecarga significativa na rede, visto que para cada comando seriam enviadas 2 mensagens para todos os nós da rede (1a e 2a) e um nó teria que receber 2 mensagens de cada nó da rede (1b e 2b).\nPara mitigar isso, uma otimização crucial é a eleição de um Líder, que simplifica a Fase 1 para decisões subsequentes, reduzindo o tráfego de rede.","cliente#Cliente":"Para conseguir utilizar o KV-Store, sem ter acesso direto aos nós e uma forma de executar essa funções por eles, todos os nós também implementam a seguinte definição gRPC:\nservice KVStore{ rpc Get(GetRequest) returns (GetResponse); rpc Set(SetRequest) returns (SetResponse); rpc Delete(DeleteRequest) returns (DeleteResponse); rpc List(ListRequest) returns (ListResponse); rpc ListLog(ListRequest) returns (ListLogResponse); rpc TryElectSelf(TryElectRequest) returns (TryElectResponse); } message GetRequest { string key = 1; } message GetResponse { string value = 1; bool found = 2; string error_message = 3; } message SetRequest { string key = 1; string value = 2; } message SetResponse { bool success = 1; string error_message = 2; } message DeleteRequest { string key = 1; } message DeleteResponse { bool success = 1; string error_message = 2; } message ListRequest{} message ListResponse { repeated KeyValuePair pairs = 1; string error_message = 3; // Mensagem de erro, se houver } message KeyValuePair { string key = 1; string value = 2; } message ListLogResponse { repeated LogEntry entries = 1; string errorMessage = 2; } message LogEntry { int64 slot_id = 1; Command command = 2; // Comando associado ao log } message Command{ paxos.CommandType type = 1; // tipo do comando string key = 2; // chave do valor a ser manipulado string value = 3; // valor a ser manipulado, se aplicável int64 proposal_id = 4; // número da proposta associada ao comando } message TryElectRequest { } message TryElectResponse { bool success = 1; // Indica se a eleição foi bem-sucedida string error_message = 2; // Mensagem de erro, se houver } Assim, é possível utilizar um cliente gRPC que faz essas chamadas para algum nó específico.\nPara uma melhor interação com o usuário, foi desenvolvido também um servidor HTTP (também em Golang), que atua como cliente gRPC do serviço KVStore. Assim, acompanhado do frontend desenvolvido em React, podemos visualizar e mandar comandos para cada nó do sistema.","conclusão#Conclusão":"A implementação desse projeto foi algo desafiador e que trouxe muito aprendizado sobre problemas de concorrência e sistemas distribuidos, além de possibilitar uma maior prática com Golang que é uma linguagem muito interessante para sistemas concorrentes e o protocolo de comunicação gRPC.\nO código para o projeto pode ser encontrado no nosso Repositório do GitHub junto com instruções de como executar todos os serviços envolvidos.","eleição-do-líder#Eleição do líder":"Para eleger o líder de um sistema paxos podemos utilizar o próprio paxos mas é um pouco mais complexo por causa de algumas peculiaridades.\nComo um nó decide se ele deve tentar se eleger lider?\nA forma mais simples que conseguimos pensar é por meio de heartbeats, onde o líder atual envia periodicamente uma mensagem de heart beat para todos os nós da rede. Caso um nó fique mais que um certo tempo sem receber um heart beat do líder, ele assume que o líder está offline e após um certo atraso aleatório (para evitar multiplos nós iniciando eleição ao mesmo tempo) ele tenta se propor como líder.\nPara essa parte, utilizamos as seguintes funções RPC.\nservice Paxos{ rpc ProposeLeader(ProposeLeaderRequest) returns (ProposeLeaderResponse); rpc SendHeartbeat(LeaderHeartbeat) returns (LeaderHeartbeatResponse); } message ProposeLeaderRequest{ int64 proposal_id = 1; // Número da proposta para a eleição do líder string candidate_address = 2; // Endereço do candidato a líder } message ProposeLeaderResponse{ bool success = 1; string error_message = 2; // Mensagem de erro, se houver int64 current_highest_leader_proposal_id = 3; // Número da proposta do líder atual string current_leader_address = 4; // Endereço do líder atual int64 highest_decided_slot_id = 5; // Slot mais alto decidido até o momento } message LeaderHeartbeat{ string leader_address = 1; // Endereço do líder int64 current_proposal_id = 2; // Número da proposta atual do líder int64 highest_decided_slot_id = 3; // Slot mais alto decidido até o momento } message LeaderHeartbeatResponse{ bool success = 1; // Indica se o heartbeat foi bem-sucedido string error_message = 2; // Mensagem de erro, se houver int64 known_highest_slot_id = 3; // Slot mais alto que o Acceptor/Learner conhece } Além disso, para evitar problemas que encontramos durante os testes, caso mais de 1 nó perceba a falta de líder, e começem uma eleição, caso o nó receba alguma indicação que já está acontecendo uma eleição com um ID maior que a eleição dele, seja por receber a proposta diretamente, ou por receber uma negação de outro nó contendo esse ID maior, ele aborta a própria eleição.","grpc-e-protobuf#gRPC e protobuf":"A comunicação do gRPC necessita de uma definição protobuf das funções, parametros e respostas implementadas pelos nós.\nTodo nó do nosso sistema implementa as seguintes funções:\nservice Paxos{ rpc Prepare(PrepareRequest) returns (PrepareResponse); rpc Accept(AcceptRequest) returns (AcceptResponse); rpc ProposeLeader(ProposeLeaderRequest) returns (ProposeLeaderResponse); } message PrepareRequest { int64 proposal_id = 1; // número da proposta int64 slot_id = 2; // número do slot da proposta } enum CommandType{ UNKNOWN = 0; // comando desconhecido SET = 1; // comando para definir um valor DELETE = 2; // comando para deletar um valor } message Command{ CommandType type = 1; // tipo do comando string key = 2; // chave do valor a ser manipulado bytes value = 3; // valor a ser manipulado, se aplicável int64 proposal_id = 4; // número da proposta associada ao comando } message PrepareResponse { bool success = 1; string error_message = 2; // mensagem de erro, se houver int64 accepted_proposal_id = 3; // número da proposta aceita Command accepted_command = 4; // comando aceito, se houver int64 current_proposal_id = 5; // número da proposta atual } message AcceptRequest { int64 proposal_id = 1; // número da proposta int64 slot_id = 2; // número do slot da proposta Command command = 3; // comando a ser aceito } message AcceptResponse { bool success = 1; // indica se a aceitação foi bem-sucedida int64 current_proposal_id = 2; // número da proposta aceita string error_message = 3; // mensagem de erro, se houver } No caso, a função Prepare corresponde a FASE 1 e a função Accept corresponde a FASE 2 com PrepareRequest sendo 1a e PrepareResponse sendo 1b, e assim também para o accept.","implementação#Implementação":"Para a implementação desse projeto, utilizamos Golang como linguagem principal, visto que ter um suporte muito bom para concorrência e comunicação distribuída, facilitando o desenvolvimento das funcionalidades necessárias. Já para a comunicação entre os nós, utilizamos gRPC.","o-que-é-um-algoritmo-de-consenso-distribuído#O que é um algoritmo de Consenso Distribuído?":"Para dar um pouco de contexto, primeiro vamos definir um Sistema Distribuído.\nSistemas distribuídos são caracterizados por um conjunto de computadores independentes que se apresentam ao usuário como um sistema único e coerente. Esses sistemas são projetados para alcançar escalabilidade, disponibilidade e tolerância a falhas, características essenciais em aplicações modernas como bancos de dados distribuídos, sistemas de arquivos e plataformas de computação em nuvem.\nCom isso, uma das maiores dificuldades nesses ambientes distribuídos é a coordenação entre os nós participantes da aplicação, especialmente quando é necessário garantir consistência entre estados replicados, em cenários onde falhas (nós indisponíveis, problemas de rede) podem ocorrer.\nDiante desse problema, foram desenvolvidos os algoritmos de consenso distribuído, como o Paxos ou o Raft, que servem para coordenar os nós e assegurar um acordo sobre valores ou operações, mesmo em condições adversas.","o-que-é-um-kv-store#O que é um KV-Store?":"Resumidamente, um Key-Value store é um tipo de banco de dados mais simples e eficiente que armazena os dados como pares chave-valor. Tem maior desempenho para leitura e escrita visto que não tem um esquema rígido nem relações entre valores armazenados. É muito utilizado em sistemas distribuídos e para cache.","registry#Registry":"Certo, mas como os nós e o servidor HTTP sabem os endereços dos nós para conseguirem fazer as requisições gRPC?\nTambém desenvolvemos um serviço de registry simples, também por meio de gRPC, no qual cada nó se registra ao iniciar e permite que sejam consultados os endereços de todos os nós do sistema. Além da utilização de heartbeats para conhecimento de qual nó está ativo ou não.\nO registry é definido pelo seguinte protobuf:\nservice Registry { rpc Register(RegisterRequest) returns (RegisterResponse); rpc ListAll(google.protobuf.Empty) returns (ListResponse); rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse); }","sincronização#Sincronização":"A parte de sincronização diz respeito a sincronização do estado dos comandos decididos entre todos os nós.\nSe temos um sistema com 50 nós rodando, fazemos a inserção de alguns valores e depois 10 novos nós são conectados, eles precisam saber do histórico dos valores decididos pelos outros 50. Para isso, também temos a seguinte função:\nservice Paxos{ rpc Learn(LearnRequest) returns (LearnResponse); } message LearnRequest{ int64 slot_id = 1; // Número do slot que está sendo aprendido } message LearnResponse{ bool decided = 1; // Indica se o slot foi decidido Command command = 2; // Comando associado ao slot, se decidido } Quando um nó recebe um HeartBeat, é enviado junto o número do ultimo slot decidido pelo sistema e, caso seja maior que o que o nó tem no seu estado interno, ele executa Learn até sincronizar todo o seu estado.\nEssa sincronização também é feita durante a eleição de um novo líder caso necessário.","um-kv-store-com-paxos#Um KV-Store com Paxos":"Certo, mas como juntar as duas coisas?\nComo dito anteriormente, em um sistema real utilizando paxos, teríamos um fluxo contínuo de comandos acordados aplicados em um estado distribuído. Assim, podemos entender o estado do KV-store como o resultado da aplicação em ordem de todos os comandos decididos pelas rodadas de Paxos.\nPara esse projeto definimos os seguintes comandos:\nSET key value DELETE key Exemplo:\nSe tivermos os seguintes 2 comandos decididos:\nSET chave1 valor1 SET chave2 valor2 O estado seria { chave1: valor1, chave2: valor2 }\nCaso fizessemos DELETE chave1, teríamos: { chave2: valor2 }"},"title":"KVStore"},"/blog/windowsvm/":{"data":{"":"Neste post, vou compartilhar e deixar registrado para meu uso no futuro o processo de criação de uma máquina virtual Windows 11 no Linux usando QEMU/KVM.","configurar-disco-rígido#Configurar Disco Rígido":"Aqui você pode escolher o tamanho do disco rígido virtual. Recomendo pelo menos 64GB para o Windows 11, mas se você planeja instalar muitos programas, considere aumentar esse valor, principalmente se for usar para jogos.\nTambém há a possibilidadde de usar um disco inteiro existente com acesso direto, via Passthrough, mas isso é um assunto para outro post e é mais avançado.","configurar-memória-e-cpu#Configurar Memória e CPU":"Aqui escolha a quantidade de memória RAM e CPU que você quer alocar para a máquina virtual.\nRecomendo no mínimo 8GB de RAM e 4 núcleos de CPU para uma boa performance.\nDepois de configurar, clique em “Forward”.","configuração-da-máquina-virtual#Configuração da Máquina Virtual":"Agora vamos para a parte interessante, que é configurar a instalar a máquina virtual.\nUma vez que tenha tudo instalado e confgurado, você pode iniciar o virt-manager (Gerenciador de Máquinas Virtuais) a partir do menu do seu sistema ou digitando virt-manager no terminal ou pesquisando no seu launcher favorito.\nSe tudo deu certo, você verá uma interface assim:\nAgora, clique no ícone de criar uma nova máquina virtual e siga os seguintes passos:","configuração-do-host#Configuração do Host":"Antes de começãr a configurar a máquina virtual, primeiro vamos configurar o libvirt para permitir que o usuário atual possa gerenciar as máquinas virtuais sem precisar de privilégios de superusuário.\nsudo usermod -aG libvirt $(whoami) newgrp libvirt Agora, vamos iniciar o serviço do libvirt e habilitá-lo para iniciar automaticamente na inicialização do sistema:\nsudo systemctl enable --now libvirtd","configuração-do-libvirt#Configuração do libvirt":"Durante a instalação da VM na minha máquina, tive alguns problemas com a questão de acesso a rede e também de permissões de usuário, então tive que fazer as seguintes alterações:\nEm /etc/libvirt/qemu.conf, descomente a linha user e altere o valor para o seu usuário\n... # The user for QEMU processes run by the system instance. It can be # specified as a user name or as a user id. The qemu driver will try to # parse this value first as a name and then, if the name doesn't exist, # as a user id. # # Since a sequence of digits is a valid user name, a leading plus sign # can be used to ensure that a user id will not be interpreted as a user # name. # # Some examples of valid values are: # # user = \"qemu\" # A user named \"qemu\" # user = \"+0\" # Super user (uid=0) # user = \"100\" # A user named \"100\" or a user with uid=100 # user = \"seu_usuario\" ... Além disso, precisei mudar o backend do firewall para usar iptables, em /etc/libvirt/network.conf\n... # Master configuration file for the network driver. # All settings described here are optional - if omitted, sensible # defaults are used. # firewall_backend: # # determines which subsystem to use to setup firewall packet # filtering rules for virtual networks. # # Supported settings: # # iptables - use iptables commands to construct the firewall # nftables - use nft commands to construct the firewall # # If firewall_backend isn't configured, libvirt will choose the # first available backend from the following list: # # [nftables, iptables] # # If no backend is available on the host, then the network driver # will fail to start, and an error will be logged. # # (NB: switching from one backend to another while there are active # virtual networks *is* supported. The change will take place the # next time that libvirtd/virtnetworkd is restarted - all existing # virtual networks will have their old firewalls removed, and then # reloaded using the new backend.) # firewall_backend = \"iptables\" ... Caso você não tenha o iptables instalado, você pode instalar com o seguinte comando:\nsudo pacman -S iptables","configuração-pós-instalação#Configuração Pós-Instalação":"Uma vez finalmente com o windows instalado, vamos fazer algumas configurações adicionais para melhorar a performance e a integração com o Linux.\nAbra o explorador de arquivos e vá até o drive de CD-ROM onde estão os drivers VirtIO.\nExecute o instalador do virtio-win-gt-x64.msi e siga os passos para instalar todos os drivers.\nDepois instale o virtio-win-guest-tools que vai instalar o QEMU Guest Agent, que é um serviço que permite a comunicação entre o host e a máquina virtual, permitindo funcionalidades como desligamento seguro, sincronização de tempo, etc.\nUma vez instalados, você pode ir no menu do virt-manager View -\u003e Scale to Display e ativar Auto resize VM with window para que a resolução da máquina virtual se ajuste automaticamente ao tamanho da janela.\nAgora pode desligar a máquina para que possamos fazer mais algumas configurações.","configurações-adicionais#Configurações Adicionais":"No menu Overview, mude o firmware para UEFI x86_64: /usr/share/edk2/x64/OVMF_CODE.secboot.4m.fd\nCaso você não tenha o OVMF instalado, você pode instalar com o seguinte comando:\nsudo pacman -S edk2-ovmf Clique em “Apply”.\nAgora vamos adicionar os drivers VirtIO que você baixou anteriormente.\nVá em Add Hardware \u003e Storage \u003e Select or create custom storage \u003e Browse Local e selecione o arquivo ISO dos drivers VirtIO. Depois mude o device type para CDROM device e clique em Finish.\nTambém é interessante trocar o bus type do disco rígido para VirtIO para melhorar a performance. Vá em SATA Disk 1 e mude o bus type para VirtIO. Clique em Apply.\nPor último, vamos fazer a emulação do chip TPM, que é necessário para o Windows 11.\nDeve ter por padrão um menu escrito TPM vNone. Vá nele, abra o menu de opções avançadas e selecione no dropdown de versão 2.0. Depois clique em Apply.\nAgora pode iniciar a instalação clicando em Begin Installation.","configurações-no-host#Configurações no Host":"Agora que já temos o Windows instalado, vamos fazer algumas configurações adicionais no host para melhorar a performance.\nPrimeiramente, podemos remover CD-ROM com os drivers VirtIO, já que não precisamos mais deles. Para isso, selecione o CD-ROM na lista de hardware e clique em Remove. Provavelmente é o SATA CDROM 2.\nCaso você queria usar uma camera, como no meu caso, estou fazendo a instalação em um notebook, para adicionar a camera a VM, basta ir em Add Hardware \u003e USB Host Device e encontrar o seu dispositivo e adicioná-lo.\nAlém disso, pelo menos no meu notebook, tive problemas com entrada de audio, então tive que fazer a seguinte configuração na aba Overview editando manualmente o XML de configuração, trocando a parte de audio por essa configuração:","considerações-finais#Considerações Finais":"Bom, a ideia desse post era deixar registrado o processo que segui para instalar o Windows 11 no Linux usando QEMU/KVM, para que eu possa consultar no futuro caso precise fazer novamente e para deixar disponível para quem mais possa precisar visto que eu mesmo tive dificuldades para encontrar um guia completo e atualizado sobre o assunto.\nNo futuro pretendo fazer mais posts sobre configurações avançadas, como passthrough de GPU, USB, CPU pinning, etc.\nAlém disso, quero deixar claro que esse processo pode variar dependendo do hardware e da distribuição Linux que você está usando, então é sempre bom consultar a documentação oficial do QEMU/KVM e do VirtIO para mais detalhes.\nTambém, obviamente, como é uma máquina virtual, não espere performance igual a de um sistema nativo, mas com as configurações corretas, a performance pode ser muito boa e suficiente para a maioria das tarefas.\nNo meu caso, tenho uma máquina relativamente potente, com a seguinte configuração:\nEntão consigo deixar 16GB de RAM e 8 núcleos de CPU para a máquina virtual, o que é mais do que suficiente para o meu uso, enquanto ainda consigo usar o Linux normalmente.","criar-máquina-virtual#Criar máquina Virtual":"Aqui, mantenha as opções padrão e clique em “Forward”.","finalizar-configuração#Finalizar Configuração":"Agora de um nome para a máquina virtual e marque a opção “Customize configuration before install” para fazer algumas configurações adicionais.","instalação-do-windows-11#Instalação do Windows 11":"Ao iniciar a instalação, você verá na tela escrito para apertar qualquer tecla para iniciar a partir do CD/DVD. Aperte qualquer tecla e será redirecionado para a tela de instalação do Windows.\nFaça a configuração inicial de idioma, teclado e clique em Next.\nNa aba de Product Key caso você tenha uma chave, insira ela aqui. Caso contrário, clique em I don't have a product key para continuar a instalação sem a chave.\nNa seleção de imagem selecione Windows 11 Home.","instalação-dos-drivers-virtio#Instalação dos Drivers VirtIO":"Na tela de seleção de disco, como escolhemos usar o bus type virtio, o Windows não reconhece o disco rígido, então precisamos carregar os drivers VirtIO.\nCaso apareça o disco (no caso de você ter mantido SATA) o disco vai aparecer, mas ainda assim, instale os drivers pois são utilizados para outros dispositivos também.\nPara isso, vá em Load Driver.\nAbra o drive de CD-ROM e selecione a pasta viostor\\w11\\amd64 e clique em OK.\nDesabilite a opção de mostrar apenas drivers compatíveis e clique install.\nDepois vá novamente em Load Driver \u003e Browse e selecione a pasta NetKVM\\w11\\amd64 e clique em OK e instale.\nAgora pode clicar em Next e continuar a instalação normalmente.\nPode ser que o processo demore um pouco, então tenha paciência. Na minha máquina demorou cerca de 15 minutos para completar ir para a parte de configuração inicial do Windows.\nNessa parte, siga os passos para configurar o Windows como preferir.\nSe aparecer uma tela de erro dizendo que não é possível conectar a internet, provavelmente o driver faltou alguma configuração relacionada a rede mencionada anteriormente, então volte e veja se está tudo certo.\nCaso tenha ido para uma tela de verifiação de atualizações, muito provavelmente deu tudo certo, e é só esperar mais um pouco.\nComo a Microsoft é chata, vai pedir para você logar em uma conta Microsoft ou criar uma e até o momento não descobri se é possível pular essa etapa, então crie uma conta Microsoft ou use uma que você já tenha.","por-que#Por que?":"Bom, se você assim como eu, prefere usar alguma distro Linux como sistema principal ou, assim como eu, não gosta do Windows, mas precisa usar o Windows para algumas tarefas específicas, como trabalho, ou alguns softwares que só rodam no Windows, ou jogos que só rodam no Windows (apesar disso não ser mais tão real assim), ou até mesmo para desenvolvimento de software que precisa ser testado no Windows, uma máquina virtual é uma ótima solução.","qemukvm#QEMU/KVM":"Como sou usuário de Arch Linux, vou usar o gerenciador de pacotes pacman para instalar os pacotes necessários. Se você estiver usando outra distro, adapte os comandos conforme necessário.\nsudo pacman -S qemu-full libvirt virt-manager virt-viewer dnsmasq qemu-full: O emulador de hardware e hypervisor. libvirt: Biblioteca para gerenciar máquinas virtuais. virt-manager: Interface gráfica para gerenciar máquinas virtuais. virt-viewer: Ferramenta para visualizar máquinas virtuais. dnsmasq: Servidor DHCP e DNS leve.","requisitos#Requisitos":"Um computador com Linux instalado (de preferência uma distro que suporte KVM, como Ubuntu, Fedora, Arch, etc).","selecionar-iso#Selecionar ISO":"Nessa segunda tela, encontre a ISO do Windows 11 que você baixou anteriormente clicando em “Browse” e depois em “Browse Local”.\nApós selecionar a ISO, clique em “Forward”.","virtio-drivers#VirtIO Drivers":"Para que a integração entre o Windows e o QEMU/KVM funcione corretamente, você precisará dos drivers VirtIO.\nIsso pois o Windows 11 não reconhece nativamente os dispositivos virtuais criados pelo QEMU/KVM, como o disco e a placa de rede.\nAlém disso, por meio desses drivers, você terá melhor desempenho com performance quase nativa, visto que o Windows vai saber que está rodando em uma máquina virtual e vai otimizar o uso dos recursos.\nPara instalar no Arch Linux, você pode usar o seguinte comando:\nsudo pacman -s virtio-win Ou você pode baixar diretamente do site oficial: VirtIO Drivers","windows-11-iso#Windows 11 ISO":"Você pode baixar a ISO do Windows 11 diretamente do site da Microsoft: Download Windows 11"},"title":"VM Windows no Linux"}}